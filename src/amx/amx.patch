diff -ruNpw amx_orig/amx.c amx/amx.c
--- amx_orig/amx.c	2005-07-23 18:57:50.000000000 +0700
+++ amx/amx.c	2012-04-07 13:22:35.385231600 +0700
@@ -21,6 +21,17 @@
  *  Version: $Id: amx.c 3365 2005-07-23 15:57:48Z thiadmer $
  */
 
+/* This is a slightly modified version of the original file, specially for crashdetect.
+ *   - ABORT() synchronizes AMX registers with amx_Exec()'s local variables
+ *   - ABORT() calls external error handler amx_Error(AMX *amx, cell index, int error),
+ *     where "error" is the error code and "index" is the index of the current public
+ *   - CHKSTACK(), CHKMARGIN() and CHKHEAP() now use the ABORT() macro instead of return
+ *   - The CIP register (amx->cip) is updated on each iteration of the instruction dispatch loop
+ *   - The CALL.pri and JUMP.pri opcodes have been removed
+ *   - The LREF.S.pri/alt and SREF.S.pri/alt opcodes synchronize the STK and FRM registers before
+ *     before pointer dereferencing because of a possible crash 
+ */
+
 #if BUILD_PLATFORM == WINDOWS && BUILD_TYPE == RELEASE && BUILD_COMPILER == MSVC && PAWN_CELL_SIZE == 64
   /* bad bad workaround but we have to prevent a compiler crash :/ */
   #pragma optimize("g",off)
@@ -1655,18 +1666,25 @@ int AMXAPI amx_PushString(AMX *amx, cell
 #define SKIPPARAM(n)    ( cip=(cell *)cip+(n) )
 #define PUSH(v)         ( stk-=sizeof(cell), *(cell *)(data+(int)stk)=v )
 #define POP(v)          ( v=*(cell *)(data+(int)stk), stk+=sizeof(cell) )
-#define ABORT(amx,v)    { (amx)->stk=reset_stk; (amx)->hea=reset_hea; return v; }
-
-#define CHKMARGIN()     if (hea+STKMARGIN>stk) return AMX_ERR_STACKERR
-#define CHKSTACK()      if (stk>amx->stp) return AMX_ERR_STACKLOW
-#define CHKHEAP()       if (hea<amx->hlw) return AMX_ERR_HEAPLOW
+#define ABORT(amx,v)    { (amx)->pri = pri;\
+						  (amx)->stk = stk;\
+						  (amx)->hea = hea;\
+						  (amx)->frm = frm;\
+						  amx_Error(amx, index, v);\
+                          (amx)->stk=reset_stk;\
+                          (amx)->hea=reset_hea;\
+                          return v; }
+
+#define CHKMARGIN()     if (hea+STKMARGIN>stk) ABORT(amx, AMX_ERR_STACKERR)
+#define CHKSTACK()      if (stk>amx->stp) ABORT(amx, AMX_ERR_STACKLOW)
+#define CHKHEAP()       if (hea<amx->hlw) ABORT(amx, AMX_ERR_HEAPLOW)
 
 #if defined __GNUC__ && !(defined ASM32 || defined JIT)
     /* GNU C version uses the "labels as values" extension to create
      * fast "indirect threaded" interpreter.
      */
 
-#define NEXT(cip)       goto **cip++
+#define NEXT(cip)       do { (amx)->cip=(cell)cip-(cell)code; goto **cip++; } while (0)
 
 int AMXAPI amx_Exec(AMX *amx, cell *retval, int index)
 {
@@ -2777,6 +2795,7 @@ int AMXAPI amx_Exec(AMX *amx, cell *retv
 #else
 
   for ( ;; ) {
+    amx->cip=(cell)cip-(cell)code;
     op=(OPCODE) *cip++;
     switch (op) {
     case OP_LOAD_PRI:
@@ -2806,11 +2825,15 @@ int AMXAPI amx_Exec(AMX *amx, cell *retv
       alt= * (cell *)(data+(int)offs);
       break;
     case OP_LREF_S_PRI:
+      amx->frm=frm;
+      amx->stk=stk;
       GETPARAM(offs);
       offs= * (cell *)(data+(int)frm+(int)offs);
       pri= * (cell *)(data+(int)offs);
       break;
     case OP_LREF_S_ALT:
+      amx->frm=frm;
+      amx->stk=stk;  
       GETPARAM(offs);
       offs= * (cell *)(data+(int)frm+(int)offs);
       alt= * (cell *)(data+(int)offs);
@@ -2869,11 +2892,15 @@ int AMXAPI amx_Exec(AMX *amx, cell *retv
       *(cell *)(data+(int)frm+(int)offs)=alt;
       break;
     case OP_SREF_PRI:
+      amx->frm=frm;
+      amx->stk=stk;
       GETPARAM(offs);
       offs= * (cell *)(data+(int)offs);
       *(cell *)(data+(int)offs)=pri;
       break;
     case OP_SREF_ALT:
+      amx->frm = frm;
+      amx->stk = stk;
       GETPARAM(offs);
       offs= * (cell *)(data+(int)offs);
       *(cell *)(data+(int)offs)=alt;
@@ -3076,10 +3103,6 @@ int AMXAPI amx_Exec(AMX *amx, cell *retv
       PUSH(((unsigned char *)cip-code)+sizeof(cell));/* skip address */
       cip=JUMPABS(code, cip);                   /* jump to the address */
       break;
-    case OP_CALL_PRI:
-      PUSH((unsigned char *)cip-code);
-      cip=(cell *)(code+(int)pri);
-      break;
     case OP_JUMP:
       /* since the GETPARAM() macro modifies cip, you cannot
        * do GETPARAM(cip) directly */
@@ -3484,9 +3507,6 @@ int AMXAPI amx_Exec(AMX *amx, cell *retv
     case OP_SYMTAG:
       SKIPPARAM(1);
       break;
-    case OP_JUMP_PRI:
-      cip=(cell *)(code+(int)pri);
-      break;
     case OP_SWITCH: {
       cell *cptr;
 
diff -ruNpw amx_orig/amx.h amx/amx.h
--- amx_orig/amx.h	2005-07-23 17:07:00.000000000 +0700
+++ amx/amx.h	2012-04-07 13:56:54.882028100 +0700
@@ -21,6 +21,8 @@
  *  Version: $Id: amx.h 3363 2005-07-23 09:03:29Z thiadmer $
  */
 
+#include <stddef.h>
+
 #if defined FREEBSD && !defined __FreeBSD__
   #define __FreeBSD__
 #endif
@@ -371,6 +373,7 @@ int AMXAPI amx_Allot(AMX *amx, int cells
 int AMXAPI amx_Callback(AMX *amx, cell index, cell *result, cell *params);
 int AMXAPI amx_Cleanup(AMX *amx);
 int AMXAPI amx_Clone(AMX *amxClone, AMX *amxSource, void *data);
+int AMXAPI amx_Error(AMX *amx, cell index, int error);
 int AMXAPI amx_Exec(AMX *amx, cell *retval, int index);
 int AMXAPI amx_FindNative(AMX *amx, const char *name, int *index);
 int AMXAPI amx_FindPublic(AMX *amx, const char *funcname, int *index);
diff -ruNpw amx_orig/amxaux.c amx/amxaux.c
--- amx_orig/amxaux.c	2005-07-23 17:07:00.000000000 +0700
+++ amx/amxaux.c	2012-04-07 14:12:45.576404700 +0700
@@ -26,7 +26,7 @@
 #include "amx.h"
 #include "amxaux.h"
 
-size_t AMXAPI aux_ProgramSize(char *filename)
+size_t AMXAPI aux_ProgramSize(const char *filename)
 {
   FILE *fp;
   AMX_HEADER hdr;
@@ -41,7 +41,7 @@ size_t AMXAPI aux_ProgramSize(char *file
   return (hdr.magic==AMX_MAGIC) ? (size_t)hdr.stp : 0;
 }
 
-int AMXAPI aux_LoadProgram(AMX *amx, char *filename, void *memblock)
+int AMXAPI aux_LoadProgram(AMX *amx, const char *filename, void *memblock)
 {
   FILE *fp;
   AMX_HEADER hdr;
@@ -52,6 +52,7 @@ int AMXAPI aux_LoadProgram(AMX *amx, cha
     return AMX_ERR_NOTFOUND;
   fread(&hdr, sizeof hdr, 1, fp);
   amx_Align16(&hdr.magic);
+  amx_Align16((uint16_t *)&hdr.flags);
   amx_Align32((uint32_t *)&hdr.size);
   amx_Align32((uint32_t *)&hdr.stp);
   if (hdr.magic != AMX_MAGIC) {
@@ -135,15 +136,6 @@ static char *messages[] = {
   return messages[errnum];
 }
 
-enum {
-  CODE_SECTION,
-  DATA_SECTION,
-  HEAP_SECTION,
-  STACK_SECTION,
-  /* ----- */
-  NUM_SECTIONS
-};
-
 int AMXAPI aux_GetSection(AMX *amx, int section, cell **start, size_t *size)
 {
   AMX_HEADER *hdr;
diff -ruNpw amx_orig/amxaux.h amx/amxaux.h
--- amx_orig/amxaux.h	2005-07-23 17:07:00.000000000 +0700
+++ amx/amxaux.h	2012-04-07 14:09:51.131427000 +0700
@@ -30,9 +30,8 @@ extern  "C" {
 #endif
 
 /* loading and freeing programs */
-size_t AMXAPI aux_ProgramSize(char *filename);
-int AMXAPI aux_LoadProgram(AMX *amx, char *filename, void *memblock,
-                           int AMXAPI (*amx_Debug)(AMX*));
+size_t AMXAPI aux_ProgramSize(const char *filename);
+int AMXAPI aux_LoadProgram(AMX *amx, const char *filename, void *memblock);
 int AMXAPI aux_FreeProgram(AMX *amx);
 
 /* a readable error message from an error code */
diff -ruNpw amx_orig/amxdbg.c amx/amxdbg.c
--- amx_orig/amxdbg.c	2005-07-23 17:07:00.000000000 +0700
+++ amx/amxdbg.c	2012-04-07 13:22:35.388231800 +0700
@@ -22,6 +22,7 @@
  *
  *  Version: $Id: amxdbg.c 3363 2005-07-23 09:03:29Z thiadmer $
  */
+
 #include <assert.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -67,6 +68,7 @@ int AMXAPI dbg_LoadInfo(AMX_DBG *amxdbg,
   #if BYTE_ORDER==BIG_ENDIAN
     amx_Align32((uint32_t*)&amxhdr.size);
     amx_Align16(&amxhdr.magic);
+    amx_Align16(&dbghdr.flags);
   #endif
   if (amxhdr.magic != AMX_MAGIC)
     return AMX_ERR_FORMAT;
@@ -257,8 +259,9 @@ int AMXAPI dbg_LookupFunction(AMX_DBG *a
   for (index = 0; index < amxdbg->hdr->symbols; index++) {
     if (amxdbg->symboltbl[index]->ident == iFUNCTN
         && amxdbg->symboltbl[index]->codestart <= address
-        && amxdbg->symboltbl[index]->codeend > address)
+        && amxdbg->symboltbl[index]->codeend > address) {
       break;
+    }
   } /* for */
   if (index >= amxdbg->hdr->symbols)
     return AMX_ERR_NOTFOUND;
diff -ruNpw amx_orig/amxdbg.h amx/amxdbg.h
--- amx_orig/amxdbg.h	2005-07-23 17:07:00.000000000 +0700
+++ amx/amxdbg.h	2012-04-07 13:56:41.894285200 +0700
@@ -27,6 +27,8 @@
 #ifndef AMXDBG_H_INCLUDED
 #define AMXDBG_H_INCLUDED
 
+#include <stdio.h>
+
 #ifndef AMX_H_INCLUDED
   #include "amx.h"
 #endif
@@ -63,17 +65,17 @@ extern  "C" {
 #endif
 
 typedef struct tagAMX_DBG_HDR {
-  int32_t size          PACKED; /* size of the debug information chunk */
+  uint32_t size          PACKED; /* size of the debug information chunk */
   uint16_t magic        PACKED; /* signature, must be 0xf1ef */
   char    file_version  PACKED; /* file format version */
   char    amx_version   PACKED; /* required version of the AMX */
-  int16_t flags         PACKED; /* currently unused */
-  int16_t files         PACKED; /* number of entries in the "file" table */
-  int16_t lines         PACKED; /* number of entries in the "line" table */
-  int16_t symbols       PACKED; /* number of entries in the "symbol" table */
-  int16_t tags          PACKED; /* number of entries in the "tag" table */
-  int16_t automatons    PACKED; /* number of entries in the "automaton" table */
-  int16_t states        PACKED; /* number of entries in the "state" table */
+  uint16_t flags         PACKED; /* currently unused */
+  uint16_t files         PACKED; /* number of entries in the "file" table */
+  uint16_t lines         PACKED; /* number of entries in the "line" table */
+  uint16_t symbols       PACKED; /* number of entries in the "symbol" table */
+  uint16_t tags          PACKED; /* number of entries in the "tag" table */
+  uint16_t automatons    PACKED; /* number of entries in the "automaton" table */
+  uint16_t states        PACKED; /* number of entries in the "state" table */
 } AMX_DBG_HDR           PACKED;
 #define AMX_DBG_MAGIC   0xf1ef
 
@@ -89,34 +91,34 @@ typedef struct tagAMX_DBG_LINE {
 
 typedef struct tagAMX_DBG_SYMBOL {
   ucell   address       PACKED; /* address in the data segment or relative to the frame */
-  int16_t tag           PACKED; /* tag for the symbol */
+  uint16_t tag           PACKED; /* tag for the symbol */
   ucell   codestart     PACKED; /* address in the code segment from which this symbol is valid (in scope) */
   ucell   codeend       PACKED; /* address in the code segment until which this symbol is valid (in scope) */
   char    ident         PACKED; /* kind of symbol (function/variable) */
   char    vclass        PACKED; /* class of symbol (global/local) */
-  int16_t dim           PACKED; /* number of dimensions */
+  uint16_t dim           PACKED; /* number of dimensions */
   const char name[1]    PACKED; /* ASCII string, zero-terminated */
 } AMX_DBG_SYMBOL        PACKED;
 
 typedef struct tagAMX_DBG_SYMDIM {
-  int16_t tag           PACKED; /* tag for the array dimension */
+  uint16_t tag           PACKED; /* tag for the array dimension */
   ucell   size          PACKED; /* size of the array dimension */
 } AMX_DBG_SYMDIM        PACKED;
 
 typedef struct tagAMX_DBG_TAG {
-  int16_t tag           PACKED; /* tag id */
+  uint16_t tag           PACKED; /* tag id */
   const char name[1]    PACKED; /* ASCII string, zero-terminated */
 } AMX_DBG_TAG           PACKED;
 
 typedef struct tagAMX_DBG_MACHINE {
-  int16_t automaton     PACKED; /* automaton id */
+  uint16_t automaton     PACKED; /* automaton id */
   ucell address         PACKED; /* address of state variable */
   const char name[1]    PACKED; /* ASCII string, zero-terminated */
 } AMX_DBG_MACHINE       PACKED;
 
 typedef struct tagAMX_DBG_STATE {
-  int16_t state         PACKED; /* state id */
-  int16_t automaton     PACKED; /* automaton id */
+  uint16_t state         PACKED; /* state id */
+  uint16_t automaton     PACKED; /* automaton id */
   const char name[1]    PACKED; /* ASCII string, zero-terminated */
 } AMX_DBG_STATE         PACKED;
 
